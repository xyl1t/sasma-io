{"version":3,"sources":["jsdelivr-header.js","/npm/bitecs@0.3.38/src/Constants.js","/npm/bitecs@0.3.38/src/Storage.js","/npm/bitecs@0.3.38/src/Util.js","/npm/bitecs@0.3.38/src/Serialize.js","/npm/bitecs@0.3.38/src/Entity.js","/npm/bitecs@0.3.38/src/Query.js","/npm/bitecs@0.3.38/src/Component.js","/npm/bitecs@0.3.38/src/World.js","/npm/bitecs@0.3.38/src/System.js","/npm/bitecs@0.3.38/src/index.js"],"names":[],"mappings":"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","file":"/npm/bitecs@0.3.38/dist/index.mjs/+esm","sourceRoot":"","sourcesContent":["/**\n * Bundled by jsDelivr using Rollup v2.70.1 and Terser v5.10.0.\n * Original file: /npm/bitecs@0.3.38/dist/index.mjs\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","export const TYPES_ENUM = {\n  i8: 'i8',\n  ui8: 'ui8',\n  ui8c: 'ui8c',\n  i16: 'i16',\n  ui16: 'ui16',\n  i32: 'i32',\n  ui32: 'ui32',\n  f32: 'f32',\n  f64: 'f64',\n  eid: 'eid',\n}\n\nexport const TYPES_NAMES = {\n  i8: 'Int8',\n  ui8: 'Uint8',\n  ui8c: 'Uint8Clamped',\n  i16: 'Int16',\n  ui16: 'Uint16',\n  i32: 'Int32',\n  ui32: 'Uint32',\n  eid: 'Uint32',\n  f32: 'Float32',\n  f64: 'Float64'\n}\n\nexport const TYPES = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  eid: Uint32Array,\n}\n\nexport const UNSIGNED_MAX = {\n  uint8: 2**8,\n  uint16: 2**16,\n  uint32: 2**32\n}\n","import { TYPES, TYPES_ENUM, TYPES_NAMES, UNSIGNED_MAX } from './Constants.js'\n// import { createAllocator } from './Allocator.js'\n\nconst roundToMultiple = mul => x => Math.ceil(x / mul) * mul\nconst roundToMultiple4 = roundToMultiple(4)\n\nexport const $storeRef = Symbol('storeRef')\nexport const $storeSize = Symbol('storeSize')\nexport const $storeMaps = Symbol('storeMaps')\nexport const $storeFlattened = Symbol('storeFlattened')\nexport const $storeBase = Symbol('storeBase')\nexport const $storeType = Symbol('storeType')\n\nexport const $storeArrayElementCounts = Symbol('storeArrayElementCounts')\nexport const $storeSubarrays = Symbol('storeSubarrays')\nexport const $subarrayCursors = Symbol('subarrayCursors')\nexport const $subarray = Symbol('subarray')\nexport const $subarrayFrom = Symbol('subarrayFrom')\nexport const $subarrayTo = Symbol('subarrayTo')\nexport const $parentArray = Symbol('parentArray')\nexport const $tagStore = Symbol('tagStore')\n\nexport const $queryShadow = Symbol('queryShadow')\nexport const $serializeShadow = Symbol('serializeShadow')\n\nexport const $indexType = Symbol('indexType')\nexport const $indexBytes = Symbol('indexBytes')\n\nexport const $isEidType = Symbol('isEidType')\n\nconst stores = {}\n\n// const alloc = createAllocator()\n\nexport const resize = (ta, size) => {\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\n  const newTa = new ta.constructor(newBuffer)\n  newTa.set(ta, 0)\n  return newTa\n}\n\nexport const createShadow = (store, key) => {\n  if (!ArrayBuffer.isView(store)) {\n    const shadowStore = store[$parentArray].slice(0)\n    store[key] = store.map((_,eid) => {\n      const { length } = store[eid]\n      const start = length * eid\n      const end = start + length\n      return shadowStore.subarray(start, end)\n    })\n  } else {\n    store[key] = store.slice(0)\n  }\n}\n\nconst resizeSubarray = (metadata, store, storeSize) => {\n  const cursors = metadata[$subarrayCursors]\n  let type = store[$storeType]\n  const length = store[0].length\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (cursors[type] === 0) {\n\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n    \n    // // for threaded impl\n    // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n\n    array.set(metadata[$storeSubarrays][type])\n    \n    metadata[$storeSubarrays][type] = array\n    \n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n}\n\nconst resizeRecursive = (metadata, store, size) => {\n  Object.keys(store).forEach(key => {\n    const ta = store[key]\n    if (Array.isArray(ta)) {\n      resizeSubarray(metadata, ta, size)\n      store[$storeFlattened].push(ta)\n    } else if (ArrayBuffer.isView(ta)) {\n      store[key] = resize(ta, size)\n      store[$storeFlattened].push(store[key])\n    } else if (typeof ta === 'object') {\n      resizeRecursive(metadata, store[key], size)\n    }\n  })\n}\n\nexport const resizeStore = (store, size) => {\n  if (store[$tagStore]) return\n  store[$storeSize] = size\n  store[$storeFlattened].length = 0\n  Object.keys(store[$subarrayCursors]).forEach(k => {\n    store[$subarrayCursors][k] = 0\n  })\n  resizeRecursive(store, store, size)\n}\n\nexport const resetStore = store => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      ta.fill(0)\n    })\n    Object.keys(store[$storeSubarrays]).forEach(key => {\n      store[$storeSubarrays][key].fill(0)\n    })\n  }\n}\n\nexport const resetStoreFor = (store, eid) => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\n      else ta[eid].fill(0)\n    })\n  }\n}\n\nconst createTypeStore = (type, length) => {\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\n  const buffer = new ArrayBuffer(totalBytes)\n  const store = new TYPES[type](buffer)\n  store[$isEidType] = type === TYPES_ENUM.eid\n  return store\n}\n\nexport const parentArray = store => store[$parentArray]\n\nconst createArrayStore = (metadata, type, length) => {\n  const storeSize = metadata[$storeSize]\n  const store = Array(storeSize).fill(0)\n  store[$storeType] = type\n  store[$isEidType] = type === TYPES_ENUM.eid\n\n  const cursors = metadata[$subarrayCursors]\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (!length) throw new Error('bitECS - Must define component array length')\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\n\n  // create buffer for type if it does not already exist\n  if (!metadata[$storeSubarrays][type]) {\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n\n    // for threaded impl\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n\n    metadata[$storeSubarrays][type] = array\n    \n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n  return store\n}\n\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\n\nexport const createStore = (schema, size) => {\n  const $store = Symbol('store')\n\n  if (!schema || !Object.keys(schema).length) {\n    // tag component\n    stores[$store] = {\n      [$storeSize]: size,\n      [$tagStore]: true,\n      [$storeBase]: () => stores[$store]\n    }\n    return stores[$store]\n  }\n\n  schema = JSON.parse(JSON.stringify(schema))\n\n  const arrayElementCounts = {}\n  const collectArrayElementCounts = s => {\n    const keys = Object.keys(s)\n    for (const k of keys) {\n      if (isArrayType(s[k])) {\n        if (!arrayElementCounts[s[k][0]]) arrayElementCounts[s[k][0]] = 0\n        arrayElementCounts[s[k][0]] += s[k][1]\n      } else if (s[k] instanceof Object) {\n        collectArrayElementCounts(s[k])\n      }\n    }\n  }\n  collectArrayElementCounts(schema)\n\n  const metadata = {\n    [$storeSize]: size,\n    [$storeMaps]: {},\n    [$storeSubarrays]: {},\n    [$storeRef]: $store,\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\n    [$storeFlattened]: [],\n    [$storeArrayElementCounts]: arrayElementCounts\n  }\n\n  if (schema instanceof Object && Object.keys(schema).length) {\n\n    const recursiveTransform = (a, k) => {\n\n      if (typeof a[k] === 'string') {\n\n        a[k] = createTypeStore(a[k], size)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n\n      } else if (isArrayType(a[k])) {\n        \n        const [type, length] = a[k]\n        a[k] = createArrayStore(metadata, type, length)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n        // Object.seal(a[k])\n\n      } else if (a[k] instanceof Object) {\n        \n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\n        // Object.seal(a[k])\n        \n      }\n\n      return a\n    }\n\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\n    stores[$store][$storeBase] = () => stores[$store]\n\n    // Object.seal(stores[$store])\n\n    return stores[$store]\n\n  }\n}\n\nexport const free = (store) => {\n  delete stores[store[$storeRef]]\n}","export const Uint32SparseSet = (length) => {\n  const dense = new Uint32Array(length)\n  const sparse = new Uint32Array(length)\n\n  let cursor = 0\n  dense.count = () => cursor + 1\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = cursor\n    dense[cursor] = val\n\n    cursor++\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense[cursor]\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n\n    cursor--\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}\n\nexport const SparseSet = () => {\n  const dense = []\n  const sparse = []\n\n  dense.sort = function (comparator) {\n    const result = Array.prototype.sort.call(this, comparator)\n\n    for(let i = 0; i < dense.length; i++) {\n      sparse[dense[i]] = i\n    }\n    \n    return result\n  }\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = dense.push(val) - 1\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense.pop()\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}","import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\nimport { $localEntities, $localEntityLookup } from \"./World.js\"\nimport { SparseSet } from \"./Util.js\"\n\nexport const DESERIALIZE_MODE = {\n  REPLACE: 0,\n  APPEND: 1,\n  MAP: 2\n}\n\nlet resized = false\n\nexport const setSerializationResized = v => { resized = v }\n\nconst concat = (a,v) => a.concat(v)\nconst not = fn => v => !fn(v)\n\nconst storeFlattened = c => c[$storeFlattened]\nconst isFullComponent = storeFlattened\nconst isProperty = not(isFullComponent)\n\nconst isModifier = c => typeof c === 'function'\nconst isNotModifier = not(isModifier)\n\nconst isChangedModifier = c => isModifier(c) && c()[1] === 'changed'\n\nconst isWorld = w => Object.getOwnPropertySymbols(w).includes($componentMap)\n\nconst fromModifierToComponent = c => c()[0]\n\nexport const canonicalize = target => {\n\n  if (isWorld(target)) return [[],new Map()]\n\n  // aggregate full components\n  const fullComponentProps = target\n    .filter(isNotModifier)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n  \n  // aggregate changed full components\n  const changedComponentProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n\n  // aggregate props\n  const props = target\n    .filter(isNotModifier)\n    .filter(isProperty)\n\n  // aggregate changed props\n  const changedProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isProperty)\n  \n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps]\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map,prop) => {\n    const $ = Symbol()\n    createShadow(prop, $)\n    map.set(prop, $)\n    return map\n  }, new Map())\n\n  return [componentProps, allChangedProps]\n}\n\n/**\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\n *\n * @param {object|array} target\n * @param {number} [maxBytes=20000000]\n * @returns {function} serializer\n */\nexport const defineSerializer = (target, maxBytes = 20000000) => {\n  const worldSerializer = isWorld(target)\n\n  let [componentProps, changedProps] = canonicalize(target)\n\n  // TODO: calculate max bytes based on target & recalc upon resize\n\n  const buffer = new ArrayBuffer(maxBytes)\n  const view = new DataView(buffer)\n\n  const entityComponentCache = new Map()\n\n  return (ents) => {\n\n    if (resized) {\n      [componentProps, changedProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (worldSerializer) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n    \n    let world\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\n      world = ents\n      ents = ents[$entityArray]\n    } else {\n      world = eidToWorld.get(ents[0])\n    }\n\n    let where = 0\n\n    if (!ents.length) return buffer.slice(0, where)\n\n    const cache = new Map()\n\n    // iterate over component props\n    for (let pid = 0; pid < componentProps.length; pid++) {\n      const prop = componentProps[pid]\n      const component = prop[$storeBase]()\n      const $diff = changedProps.get(prop)\n      const shadow = $diff ? prop[$diff] : null\n\n      if (!cache.has(component)) cache.set(component, new Map())\n\n      // write pid\n      view.setUint8(where, pid)\n      where += 1\n\n      // save space for entity count\n      const countWhere = where\n      where += 4\n\n      let writeCount = 0\n      // write eid,val\n      for (let i = 0; i < ents.length; i++) {\n        const eid = ents[i]\n\n        let componentCache = entityComponentCache.get(eid)\n        if (!componentCache) componentCache = entityComponentCache.set(eid, new Set()).get(eid)\n        \n        componentCache.add(eid)\n        \n        const newlyAddedComponent = \n          // if we are diffing\n          shadow \n          // and we have already iterated over this component for this entity\n          // retrieve cached value    \n          && cache.get(component).get(eid)\n          // or if entity did not have component last call\n          || !componentCache.has(component)\n          // and entity has component this call\n          && hasComponent(world, component, eid)\n\n        cache.get(component).set(eid, newlyAddedComponent)\n\n        if (newlyAddedComponent) {\n          componentCache.add(component)\n        } else if (!hasComponent(world, component, eid)) {\n          // skip if entity doesn't have this component\n          componentCache.delete(component)\n          continue\n        } \n\n        \n        const rewindWhere = where\n\n        // write eid\n        view.setUint32(where, eid)\n        where += 4\n\n        // if it's a tag store we can stop here\n        if (prop[$tagStore]) {\n          writeCount++\n          continue\n        }\n\n        // if property is an array\n        if (ArrayBuffer.isView(prop[eid])) {\n          const type = prop[eid].constructor.name.replace('Array', '')\n          const indexType = prop[eid][$indexType]\n          const indexBytes = prop[eid][$indexBytes]\n\n          // save space for count of dirty array elements\n          const countWhere2 = where\n          where += indexBytes\n\n          let arrayWriteCount = 0\n\n          // write index,value\n          for (let i = 0; i < prop[eid].length; i++) {\n\n            if (shadow) {\n\n              const changed = shadow[eid][i] !== prop[eid][i]\n              \n              // sync shadow\n              shadow[eid][i] = prop[eid][i]              \n\n              // if state has not changed since the last call\n              // todo: if newly added then entire component will serialize (instead of only changed values)\n              if (!changed && !newlyAddedComponent) {\n                // skip writing this value\n                continue\n              }\n            }\n            \n            // write array index\n            view[`set${indexType}`](where, i)\n            where += indexBytes\n            \n            // write value at that index\n            const value = prop[eid][i]\n            view[`set${type}`](where, value)\n            where += prop[eid].BYTES_PER_ELEMENT\n            arrayWriteCount++\n          }\n\n          if (arrayWriteCount > 0) {\n            // write total element count\n            view[`set${indexType}`](countWhere2, arrayWriteCount)\n            writeCount++\n          } else {\n            where = rewindWhere\n            continue\n          }\n        } else {\n\n          if (shadow) {\n\n            const changed = shadow[eid] !== prop[eid]\n\n            shadow[eid] = prop[eid]\n\n            // do not write value if diffing and no change\n            if (!changed && !newlyAddedComponent) {\n              // rewind the serializer\n              where = rewindWhere\n              // skip writing this value\n              continue\n            }\n\n          }  \n\n\n          const type = prop.constructor.name.replace('Array', '')\n          // set value next [type] bytes\n          view[`set${type}`](where, prop[eid])\n          where += prop.BYTES_PER_ELEMENT\n\n          writeCount++\n        }\n      }\n\n      if (writeCount > 0) {\n        // write how many eid/value pairs were written\n        view.setUint32(countWhere, writeCount)\n      } else {\n        // if nothing was written (diffed with no changes) \n        // then move cursor back 5 bytes (remove PID and countWhere space)\n        where -= 5\n      }\n    }\n    return buffer.slice(0, where)\n  }\n}\n\nconst newEntities = new Map()\n\n/**\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\n *\n * @param {object|array} target\n * @returns {function} deserializer\n */\nexport const defineDeserializer = (target) => {\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\n  let [componentProps] = canonicalize(target)\n\n  const deserializedEntities = new Set()\n\n  return (world, packet, mode=0) => {\n\n    newEntities.clear()\n    \n    if (resized) {\n      [componentProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (isWorld) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n\n    const localEntities = world[$localEntities]\n    const localEntityLookup = world[$localEntityLookup]\n\n    const view = new DataView(packet)\n    let where = 0\n\n    while (where < packet.byteLength) {\n\n      // pid\n      const pid = view.getUint8(where)\n      where += 1\n\n      // entity count\n      const entityCount = view.getUint32(where)\n      where += 4\n\n      // component property\n      const prop = componentProps[pid]\n\n      // Get the entities and set their prop values\n      for (let i = 0; i < entityCount; i++) {\n        let eid = view.getUint32(where) // throws with [changed, c, changed]\n        where += 4\n\n        if (mode === DESERIALIZE_MODE.MAP) {\n          if (localEntities.has(eid)) {\n            eid = localEntities.get(eid)\n          } else if (newEntities.has(eid)) {\n            eid = newEntities.get(eid)\n          } else {\n            const newEid = addEntity(world)\n            localEntities.set(eid, newEid)\n            localEntityLookup.set(newEid, eid)\n            newEntities.set(eid, newEid)\n            eid = newEid\n          }\n        }\n\n        if (mode === DESERIALIZE_MODE.APPEND ||  \n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\n        ) {\n          const newEid = newEntities.get(eid) || addEntity(world)\n          newEntities.set(eid, newEid)\n          eid = newEid\n        }\n\n        const component = prop[$storeBase]()\n        if (!hasComponent(world, component, eid)) {\n          addComponent(world, component, eid)\n        }\n\n        // add eid to deserialized ents after it has been transformed by MAP mode\n        deserializedEntities.add(eid)\n\n        if (component[$tagStore]) {\n          continue\n        }\n        \n        if (ArrayBuffer.isView(prop[eid])) {\n          const array = prop[eid]\n          const count = view[`get${array[$indexType]}`](where)\n          where += array[$indexBytes]\n\n          // iterate over count\n          for (let i = 0; i < count; i++) {\n            const index = view[`get${array[$indexType]}`](where)\n            where += array[$indexBytes]\n\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\n            where += array.BYTES_PER_ELEMENT\n            if (prop[$isEidType]) {\n              let localEid\n              if (localEntities.has(value)) {\n                localEid = localEntities.get(value)\n              } else if (newEntities.has(value)) {\n                localEid = newEntities.get(value)\n              } else {\n                const newEid = addEntity(world)\n                localEntities.set(value, newEid)\n                localEntityLookup.set(newEid, value)\n                newEntities.set(value, newEid)\n                localEid = newEid\n              }\n              prop[eid][index] = localEid\n            } else prop[eid][index] = value\n          }\n        } else {\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\n          where += prop.BYTES_PER_ELEMENT\n\n          if (prop[$isEidType]) {\n            let localEid\n            if (localEntities.has(value)) {\n              localEid = localEntities.get(value)\n            } else if (newEntities.has(value)) {\n              localEid = newEntities.get(value)\n            } else {\n              const newEid = addEntity(world)\n              localEntities.set(value, newEid)\n              localEntityLookup.set(newEid, value)\n              newEntities.set(value, newEid)\n              localEid = newEid\n            }\n            prop[eid] = localEid\n          } else prop[eid] = value\n        }\n      }\n    }\n\n    const ents = Array.from(deserializedEntities)\n\n    deserializedEntities.clear()\n\n    return ents\n  }\n}","import { resizeComponents } from './Component.js'\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\nimport { $localEntities, $localEntityLookup, resizeWorlds } from './World.js'\nimport { setSerializationResized } from './Serialize.js'\n\nexport const $entityMasks = Symbol('entityMasks')\nexport const $entityComponents = Symbol('entityComponents')\nexport const $entitySparseSet = Symbol('entitySparseSet')\nexport const $entityArray = Symbol('entityArray')\nexport const $entityIndices = Symbol('entityIndices')\nexport const $removedEntities = Symbol('removedEntities')\n\nlet defaultSize = 100000\n\n// need a global EID cursor which all worlds and all components know about\n// so that world entities can posess entire rows spanning all component tables\nlet globalEntityCursor = 0\nlet globalSize = defaultSize\nlet resizeThreshold = () => globalSize - (globalSize / 5)\n\nexport const getGlobalSize = () => globalSize\n\n// removed eids should also be global to prevent memory leaks\nconst removed = []\n\nexport const resetGlobals = () => {\n  globalSize = defaultSize\n  globalEntityCursor = 0\n  removed.length = 0\n}\n\nexport const getDefaultSize = () => defaultSize\n\n/**\n * Sets the default maximum number of entities for worlds and component stores.\n *\n * @param {number} newSize\n */\nexport const setDefaultSize = newSize => { \n  const oldSize = globalSize\n\n  defaultSize = newSize\n  resetGlobals()\n\n  globalSize = newSize\n  resizeWorlds(newSize)\n  resizeComponents(newSize)\n  setSerializationResized(true)\n\n  console.info(`ðŸ‘¾ bitECS - resizing all data stores from ${oldSize} to ${newSize}`)\n}\n\nexport const getEntityCursor = () => globalEntityCursor\nexport const getRemovedEntities = () => removed\n\nexport const eidToWorld = new Map()\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world) => {\n\n  // if data stores are 80% full\n  if (globalEntityCursor >= resizeThreshold()) {\n    // grow by half the original size rounded up to a multiple of 4\n    const size = globalSize\n    const amount = Math.ceil((size/2) / 4) * 4\n    setDefaultSize(size + amount)\n  }\n  \n  const eid = removed.length > Math.round(defaultSize * 0.01) ? removed.shift() : globalEntityCursor++\n  \n  world[$entitySparseSet].add(eid)\n  eidToWorld.set(eid, world)\n\n  world[$notQueries].forEach(q => {\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  })\n\n  world[$entityComponents].set(eid, new Set())\n\n  return eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const removeEntity = (world, eid) => {\n  // Check if entity is already removed\n  if (!world[$entitySparseSet].has(eid)) return\n\n  // Remove entity from all queries\n  // TODO: archetype graph\n  world[$queries].forEach(q => {\n    queryRemoveEntity(world, q, eid)\n  })\n\n  // Free the entity\n  removed.push(eid)\n\n  // remove all eid state from world\n  world[$entitySparseSet].remove(eid)\n  world[$entityComponents].delete(eid)\n\n  // remove from deserializer mapping\n  world[$localEntities].delete(world[$localEntityLookup].get(eid))\n  world[$localEntityLookup].delete(eid)\n\n  // Clear entity bitmasks\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world, eid) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  return Array.from(world[$entityComponents].get(eid))\n}\n\n/**\n * Checks the existence of an entity in a world\n * \n * @param {World} world \n * @param {number} eid \n */\nexport const entityExists = (world, eid) => world[$entitySparseSet].has(eid)","import { SparseSet } from './Util.js'\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\nimport { $componentMap, registerComponent } from './Component.js'\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\n\n\n\nexport function Not(c) { return () => [c, 'not'] }\nexport function Or(c) { return () => [c, 'or'] }\nexport function Changed(c) { return () => [c, 'changed'] }\n\nexport function Any(...comps) { return function QueryAny() { return comps } }\nexport function All(...comps) { return function QueryAll() { return comps } }\nexport function None(...comps) { return function QueryNone() { return comps } }\n\nexport const $queries = Symbol('queries')\nexport const $notQueries = Symbol('notQueries')\n\nexport const $queryAny = Symbol('queryAny')\nexport const $queryAll = Symbol('queryAll')\nexport const $queryNone = Symbol('queryNone')\n\nexport const $queryMap = Symbol('queryMap')\nexport const $dirtyQueries = Symbol('$dirtyQueries')\nexport const $queryComponents = Symbol('queryComponents')\nexport const $enterQuery = Symbol('enterQuery')\nexport const $exitQuery = Symbol('exitQuery')\n\n/**\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const enterQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const entered = q.entered.dense.slice()\n  q.entered = SparseSet()\n  return entered\n}\n\n/**\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const exitQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const exited = q.exited.dense.slice()\n  q.exited = SparseSet()\n  return exited\n}\n\nexport const registerQuery = (world, query) => {\n\n  const components = []\n  const notComponents = []\n  const changedComponents = []\n\n  query[$queryComponents].forEach(c => {\n    if (typeof c === 'function') {\n      const [comp, mod] = c()\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\n      if (mod === 'not') {\n        notComponents.push(comp)\n      }\n      if (mod === 'changed') {\n        changedComponents.push(comp)\n        components.push(comp)\n      }\n      // if (mod === 'all') {\n      //   allComponents.push(comp)\n      // }\n      // if (mod === 'any') {\n      //   anyComponents.push(comp)\n      // }\n      // if (mod === 'none') {\n      //   noneComponents.push(comp)\n      // }\n    } else {\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\n      components.push(c)\n    }\n  })\n\n\n  const mapComponents = c => world[$componentMap].get(c)\n\n  const allComponents = components.concat(notComponents).map(mapComponents)\n\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\n  const sparseSet = SparseSet()\n\n  const archetypes = []\n  // const changed = SparseSet()\n  const changed = []\n  const toRemove = SparseSet()\n  const entered = SparseSet()\n  const exited = SparseSet()\n\n  const generations = allComponents\n    .map(c => c.generationId)\n    .reduce((a,v) => {\n      if (a.includes(v)) return a\n      a.push(v)\n      return a\n    }, [])\n\n  const reduceBitflags = (a,c) => {\n    if (!a[c.generationId]) a[c.generationId] = 0\n    a[c.generationId] |= c.bitflag\n    return a\n  }\n  const masks = components\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  const notMasks = notComponents\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  // const orMasks = orComponents\n  //   .map(mapComponents)\n  //   .reduce(reduceBitmasks, {})\n\n  const hasMasks = allComponents\n    .reduce(reduceBitflags, {})\n\n  const flatProps = components\n    .filter(c => !c[$tagStore])\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\n    .reduce((a,v) => a.concat(v), [])\n\n  const shadows = []\n\n  const q = Object.assign(sparseSet, {\n    archetypes,\n    changed,\n    components,\n    notComponents,\n    changedComponents,\n    allComponents,\n    masks,\n    notMasks,\n    // orMasks,\n    hasMasks,\n    generations,\n    flatProps,\n    toRemove,\n    entered,\n    exited,\n    shadows,\n  })\n\n  world[$queryMap].set(query, q)\n  world[$queries].add(q)\n  \n  allComponents.forEach(c => {\n    c.queries.add(q)\n  })\n\n  if (notComponents.length) world[$notQueries].add(q)\n\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\n    if (!world[$entitySparseSet].has(eid)) continue\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  }\n}\n\nconst generateShadow = (q, pid) => {\n  const $ = Symbol()\n  const prop = q.flatProps[pid]\n  createShadow(prop, $)\n  q.shadows[pid] = prop[$]\n  return prop[$]\n}\n\nconst diff = (q, clearDiff) => {\n  if (clearDiff) q.changed = []\n  const { flatProps, shadows } = q\n  for (let i = 0; i < q.dense.length; i++) {\n    const eid = q.dense[i]\n    let dirty = false\n    for (let pid = 0; pid < flatProps.length; pid++) {\n      const prop = flatProps[pid]\n      const shadow = shadows[pid] || generateShadow(q, pid)\n      if (ArrayBuffer.isView(prop[eid])) {\n        for (let i = 0; i < prop[eid].length; i++) {\n          if (prop[eid][i] !== shadow[eid][i]) {\n            dirty = true\n            break\n          }\n        }\n        shadow[eid].set(prop[eid])\n      } else {\n        if (prop[eid] !== shadow[eid]) {\n          dirty = true\n          shadow[eid] = prop[eid]\n        }\n      }\n    }\n    if (dirty) q.changed.push(eid)\n  }\n  return q.changed\n}\n\n// const queryEntityChanged = (q, eid) => {\n//   if (q.changed.has(eid)) return\n//   q.changed.add(eid)\n// }\n\n// export const entityChanged = (world, component, eid) => {\n//   const { changedQueries } = world[$componentMap].get(component)\n//   changedQueries.forEach(q => {\n//     const match = queryCheckEntity(world, q, eid)\n//     if (match) queryEntityChanged(q, eid)\n//   })\n// }\n\nconst flatten = (a,v) => a.concat(v)\n\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\n\nconst getAnyComponents = aggregateComponentsFor(Any)\nconst getAllComponents = aggregateComponentsFor(All)\nconst getNoneComponents = aggregateComponentsFor(None)\n\n/**\n * Defines a query function which returns a matching set of entities when called on a world.\n *\n * @param {array} components\n * @returns {function} query\n */\n\nexport const defineQuery = (...args) => {\n  let components\n  let any, all, none\n  if (Array.isArray(args[0])) {\n    components = args[0]\n  } else {\n    // any = getAnyComponents(args)\n    // all = getAllComponents(args)\n    // none = getNoneComponents(args)\n  }\n  \n\n  if (components === undefined || components[$componentMap] !== undefined) {\n    return world => world ? world[$entityArray] : components[$entityArray]\n  }\n\n  const query = function (world, clearDiff=true) {\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\n\n    const q = world[$queryMap].get(query)\n\n    commitRemovals(world)\n\n    if (q.changedComponents.length) return diff(q, clearDiff)\n    // if (q.changedComponents.length) return q.changed.dense\n\n    return q.dense\n  }\n\n  query[$queryComponents] = components\n  query[$queryAny] = any\n  query[$queryAll] = all\n  query[$queryNone] = none\n\n  return query\n}\n\nconst bin = value => {\n  if (!Number.isSafeInteger(value)) {\n    throw new TypeError('value must be a safe integer');\n  }\n\n  const negative = value < 0;\n  const twosComplement = negative ? Number.MAX_SAFE_INTEGER + value + 1 : value;\n  const signExtend = negative ? '1' : '0';\n\n  return twosComplement.toString(2).padStart(4, '0').padStart(0, signExtend);\n}\n\n// TODO: archetype graph\nexport const queryCheckEntity = (world, q, eid) => {\n  const { masks, notMasks, generations } = q\n  let or = 0\n  for (let i = 0; i < generations.length; i++) {\n    const generationId = generations[i]\n    const qMask = masks[generationId]\n    const qNotMask = notMasks[generationId]\n    // const qOrMask = orMasks[generationId]\n    const eMask = world[$entityMasks][generationId][eid]\n    \n    // any\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\n    //   continue\n    // }\n    // not all \n    // if (qNotMask && (eMask & qNotMask) === qNotMask) {\n    // }\n    // not any\n    if (qNotMask && (eMask & qNotMask) !== 0) {\n      return false\n    }\n    // all\n    if (qMask && (eMask & qMask) !== qMask) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const queryCheckComponent = (q, c) => {\n  const { generationId, bitflag } = c\n  const { hasMasks } = q\n  const mask = hasMasks[generationId]\n  return (mask & bitflag) === bitflag\n}\n\nexport const queryAddEntity = (q, eid) => {\n  q.toRemove.remove(eid)\n  // if (!q.has(eid)) \n  q.entered.add(eid)\n  q.add(eid)\n}\n\nconst queryCommitRemovals = (q) => {\n  for (let i = q.toRemove.dense.length-1; i >= 0; i--) {\n    const eid = q.toRemove.dense[i]\n    q.toRemove.remove(eid)\n    q.remove(eid)\n  }\n}\n\nexport const commitRemovals = (world) => {\n  if (!world[$dirtyQueries].size) return\n  world[$dirtyQueries].forEach(queryCommitRemovals)\n  world[$dirtyQueries].clear()\n}\n\nexport const queryRemoveEntity = (world, q, eid) => {\n  if (!q.has(eid) || q.toRemove.has(eid)) return\n  q.toRemove.add(eid)\n  world[$dirtyQueries].add(q)\n  q.exited.add(eid)\n}\n\n\n/**\n * Resets a Changed-based query, clearing the underlying list of changed entities.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const resetChangedQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  q.changed = []\n}\n\n/**\n * Removes a query from a world.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const removeQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  world[$queries].delete(q)\n  world[$queryMap].delete(query)\n}","import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity, commitRemovals } from './Query.js'\nimport { $bitflag, $size } from './World.js'\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents, getGlobalSize, $entitySparseSet } from './Entity.js'\n\nexport const $componentMap = Symbol('componentMap')\n\nexport const components = []\n\nexport const resizeComponents = (size) => {\n  components.forEach(component => resizeStore(component, size))\n}\n\n\n/**\n * Defines a new component store.\n *\n * @param {object} schema\n * @returns {object}\n */\nexport const defineComponent = (schema, size) => {\n  const component = createStore(schema, size || getGlobalSize())\n  if (schema && Object.keys(schema).length) components.push(component)\n  return component\n}\n\nexport const incrementBitflag = (world) => {\n  world[$bitflag] *= 2\n  if (world[$bitflag] >= 2**31) {\n    world[$bitflag] = 1\n    world[$entityMasks].push(new Uint32Array(world[$size]))\n  }\n}\n\n\n/**\n * Registers a component with a world.\n *\n * @param {World} world\n * @param {Component} component\n */\nexport const registerComponent = (world, component) => {\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\n\n  const queries = new Set()\n  const notQueries = new Set()\n  const changedQueries = new Set()\n\n  world[$queries].forEach(q => {\n    if (q.allComponents.includes(component)) {\n      queries.add(q)\n    }\n  })\n\n  world[$componentMap].set(component, { \n    generationId: world[$entityMasks].length - 1,\n    bitflag: world[$bitflag],\n    store: component,\n    queries,\n    notQueries,\n    changedQueries,\n  })\n\n  if (component[$storeSize] < getGlobalSize()) {\n    resizeStore(component, getGlobalSize())\n  }\n\n  incrementBitflag(world)\n}\n\n/**\n * Registers multiple components with a world.\n *\n * @param {World} world\n * @param {Component} components\n */\nexport const registerComponents = (world, components) => {\n  components.forEach(c => registerComponent(world, c))\n}\n\n/**\n * Checks if an entity has a component.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @returns {boolean}\n */\nexport const hasComponent = (world, component, eid) => {\n  const registeredComponent = world[$componentMap].get(component)\n  if (!registeredComponent) return false\n  const { generationId, bitflag } = registeredComponent\n  const mask = world[$entityMasks][generationId][eid]\n  return (mask & bitflag) === bitflag\n}\n\n/**\n * Adds a component to an entity\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=false]\n */\nexport const addComponent = (world, component, eid, reset=false) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\n  if (hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries, notQueries } = c\n    \n  // Add bitflag to entity bitmask\n  world[$entityMasks][generationId][eid] |= bitflag\n\n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).add(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n\n/**\n * Removes a component from an entity and resets component state unless otherwise specified.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=true]\n */\nexport const removeComponent = (world, component, eid, reset=true) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries } = c\n\n  // Remove flag from entity bitmask\n  world[$entityMasks][generationId][eid] &= ~bitflag\n  \n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).delete(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n","import { $componentMap } from './Component.js'\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\nimport { resize } from './Storage.js'\nimport { SparseSet } from './Util.js'\n\nexport const $size = Symbol('size')\nexport const $resizeThreshold = Symbol('resizeThreshold')\nexport const $bitflag = Symbol('bitflag')\nexport const $archetypes = Symbol('archetypes')\nexport const $localEntities = Symbol('localEntities')\nexport const $localEntityLookup = Symbol('localEntityLookp')\n\nexport const worlds = []\n\nexport const resizeWorlds = (size) => {\n  worlds.forEach(world => {\n    world[$size] = size\n\n    for (let i = 0; i < world[$entityMasks].length; i++) {\n      const masks = world[$entityMasks][i];\n      world[$entityMasks][i] = resize(masks, size)\n    }\n    \n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\n  })\n}\n\n/**\n * Creates a new world.\n *\n * @returns {object}\n */\nexport const createWorld = (...args) => {\n  const world = typeof args[0] === 'object'\n    ? args[0]\n    : {}\n  const size = typeof args[0] === 'number' \n    ? args[0] \n    : typeof args[1] === 'number' \n      ? args[1] \n      : getGlobalSize()\n  resetWorld(world, size)\n  worlds.push(world)\n  return world\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world, size = getGlobalSize()) => {\n  world[$size] = size\n\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\n\n  world[$entityMasks] = [new Uint32Array(size)]\n  world[$entityComponents] = new Map()\n  world[$archetypes] = []\n\n  world[$entitySparseSet] = SparseSet()\n  world[$entityArray] = world[$entitySparseSet].dense\n\n  world[$bitflag] = 1\n\n  world[$componentMap] = new Map()\n\n  world[$queryMap] = new Map()\n  world[$queries] = new Set()\n  world[$notQueries] = new Set()\n  world[$dirtyQueries] = new Set()\n\n  world[$localEntities] = new Map()\n  world[$localEntityLookup] = new Map()\n\n  return world\n}\n\n/**\n * Deletes a world.\n *\n * @param {World} world\n */\nexport const deleteWorld = (world) => {\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\n  Object.keys(world).forEach(key => { delete world[key] })\n  worlds.splice(worlds.indexOf(world), 1)\n}\n\n/**\n * Returns all components registered to a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getWorldComponents = (world) => Array.from(world[$componentMap].keys())\n\n/**\n * Returns all existing entities in a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getAllEntities = (world) => world[$entitySparseSet].dense.slice(0)","/**\n * Defines a new system function.\n *\n * @param {function} update\n * @returns {function}\n */\n export const defineSystem = (update) => (world, ...args) => {\n  update(world, ...args)\n  return world\n}","import { createWorld, resetWorld, deleteWorld, getWorldComponents } from './World.js'\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents, entityExists } from './Entity.js'\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\nimport { defineSystem } from './System.js'\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\nimport { parentArray } from './Storage.js'\nimport { TYPES_ENUM } from './Constants.js'\n\nexport const pipe = (...fns) => (input) => {\n  let tmp = input\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i]\n    tmp = fn(tmp)\n  }\n  return tmp\n}\n\nexport const Types = TYPES_ENUM\n\nexport {\n\n  setDefaultSize,\n  createWorld,\n  resetWorld,\n  deleteWorld,\n  addEntity,\n  removeEntity,\n  entityExists,\n  getWorldComponents,\n  \n  registerComponent,\n  registerComponents,\n  defineComponent,\n  addComponent,\n  removeComponent,\n  hasComponent,\n  getEntityComponents,\n\n  defineQuery,\n  Changed,\n  Not,\n  enterQuery,\n  exitQuery,\n  commitRemovals,\n  resetChangedQuery,\n  removeQuery,\n\n  defineSystem,\n  \n  defineSerializer,\n  defineDeserializer,\n  DESERIALIZE_MODE,\n\n  parentArray,\n\n}\n"]}