/**
 * Bundled by jsDelivr using Rollup v2.74.1 and Terser v5.15.1.
 * Original file: /npm/bitecs@0.3.38/dist/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var e,t={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},n={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},r={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},o=256,s=65536,i=(e=4,t=>Math.ceil(t/e)*e),a=Symbol("storeRef"),c=Symbol("storeSize"),l=Symbol("storeMaps"),f=Symbol("storeFlattened"),u=Symbol("storeBase"),y=Symbol("storeType"),d=Symbol("storeArrayElementCounts"),h=Symbol("storeSubarrays"),g=Symbol("subarrayCursors"),p=Symbol("subarray"),m=Symbol("parentArray"),E=Symbol("tagStore"),b=Symbol("indexType"),S=Symbol("indexBytes"),w=Symbol("isEidType"),A={},M=(e,t)=>{const n=new ArrayBuffer(t*e.BYTES_PER_ELEMENT),r=new e.constructor(n);return r.set(e,0),r},O=(e,t)=>{if(ArrayBuffer.isView(e))e[t]=e.slice(0);else{const n=e[m].slice(0);e[t]=e.map(((t,r)=>{const{length:o}=e[r],s=o*r,i=s+o;return n.subarray(s,i)}))}},v=(e,a,c)=>{Object.keys(a).forEach((l=>{const u=a[l];Array.isArray(u)?(((e,a,c)=>{const l=e[g];let f=a[y];const u=a[0].length,E=u<=o?t.ui8:u<=s?t.ui16:t.ui32;if(0===l[f]){const t=e[d][f],o=new r[f](i(t*c));o.set(e[h][f]),e[h][f]=o,o[b]=n[E],o[S]=r[E].BYTES_PER_ELEMENT}const w=l[f],A=w+c*u;l[f]=A,a[m]=e[h][f].subarray(w,A);for(let e=0;e<c;e++){const t=u*e,o=t+u;a[e]=a[m].subarray(t,o),a[e][b]=n[E],a[e][S]=r[E].BYTES_PER_ELEMENT,a[e][p]=!0}})(e,u,c),a[f].push(u)):ArrayBuffer.isView(u)?(a[l]=M(u,c),a[f].push(a[l])):"object"==typeof u&&v(e,a[l],c)}))},P=(e,t)=>{e[E]||(e[c]=t,e[f].length=0,Object.keys(e[g]).forEach((t=>{e[g][t]=0})),v(e,e,t))},C=(e,t)=>{e[f]&&e[f].forEach((e=>{ArrayBuffer.isView(e)?e[t]=0:e[t].fill(0)}))},R=e=>e[m],T=e=>Array.isArray(e)&&"string"==typeof e[0]&&"number"==typeof e[1],j=(e,M)=>{const O=Symbol("store");if(!e||!Object.keys(e).length)return A[O]={[c]:M,[E]:!0,[u]:()=>A[O]},A[O];e=JSON.parse(JSON.stringify(e));const v={},P=e=>{const t=Object.keys(e);for(const n of t)T(e[n])?(v[e[n][0]]||(v[e[n][0]]=0),v[e[n][0]]+=e[n][1]):e[n]instanceof Object&&P(e[n])};P(e);const C={[c]:M,[l]:{},[h]:{},[a]:O,[g]:Object.keys(r).reduce(((e,t)=>({...e,[t]:0})),{}),[f]:[],[d]:v};if(e instanceof Object&&Object.keys(e).length){const a=(e,l)=>{if("string"==typeof e[l])e[l]=((e,n)=>{const o=n*r[e].BYTES_PER_ELEMENT,s=new ArrayBuffer(o),i=new r[e](s);return i[w]=e===t.eid,i})(e[l],M),e[l][u]=()=>A[O],C[f].push(e[l]);else if(T(e[l])){const[a,E]=e[l];e[l]=((e,a,l)=>{const f=e[c],u=Array(f).fill(0);u[y]=a,u[w]=a===t.eid;const E=e[g],A=l<=o?t.ui8:l<=s?t.ui16:t.ui32;if(!l)throw new Error("bitECS - Must define component array length");if(!r[a])throw new Error(`bitECS - Invalid component array property type ${a}`);if(!e[h][a]){const t=e[d][a],o=new r[a](i(t*f));o[b]=n[A],o[S]=r[A].BYTES_PER_ELEMENT,e[h][a]=o}const M=E[a],O=M+f*l;E[a]=O,u[m]=e[h][a].subarray(M,O);for(let e=0;e<f;e++){const t=l*e,o=t+l;u[e]=u[m].subarray(t,o),u[e][b]=n[A],u[e][S]=r[A].BYTES_PER_ELEMENT,u[e][p]=!0}return u})(C,a,E),e[l][u]=()=>A[O],C[f].push(e[l])}else e[l]instanceof Object&&(e[l]=Object.keys(e[l]).reduce(a,e[l]));return e};return A[O]=Object.assign(Object.keys(e).reduce(a,e),C),A[O][u]=()=>A[O],A[O]}},B=()=>{const e=[],t=[];e.sort=function(n){const r=Array.prototype.sort.call(this,n);for(let n=0;n<e.length;n++)t[e[n]]=n;return r};const n=n=>e[t[n]]===n;return{add:r=>{n(r)||(t[r]=e.push(r)-1)},remove:r=>{if(!n(r))return;const o=t[r],s=e.pop();s!==r&&(e[o]=s,t[s]=o)},has:n,sparse:t,dense:e}},_={REPLACE:0,APPEND:1,MAP:2},k=!1,U=(e,t)=>e.concat(t),I=e=>t=>!e(t),N=e=>e[f],L=N,x=I(L),$=e=>"function"==typeof e,q=I($),Y=e=>$(e)&&"changed"===e()[1],V=e=>Object.getOwnPropertySymbols(e).includes(Be),z=e=>e()[0],F=e=>{if(V(e))return[[],new Map];const t=e.filter(q).filter(L).map(N).reduce(U,[]),n=e.filter(Y).map(z).filter(L).map(N).reduce(U,[]),r=e.filter(q).filter(x),o=e.filter(Y).map(z).filter(x);return[[...t,...r,...n,...o],[...n,...o].reduce(((e,t)=>{const n=Symbol();return O(t,n),e.set(t,n),e}),new Map)]},Q=(e,t=2e7)=>{const n=V(e);let[r,o]=F(e);const s=new ArrayBuffer(t),i=new DataView(s),a=new Map;return t=>{let c;k&&([r,o]=F(e),k=!1),n&&(r=[],e[Be].forEach(((e,t)=>{t[f]?r.push(...t[f]):r.push(t)}))),Object.getOwnPropertySymbols(t).includes(Be)?(c=t,t=t[W]):c=oe.get(t[0]);let l=0;if(!t.length)return s.slice(0,l);const y=new Map;for(let e=0;e<r.length;e++){const n=r[e],s=n[u](),f=o.get(n),d=f?n[f]:null;y.has(s)||y.set(s,new Map),i.setUint8(l,e),l+=1;const h=l;l+=4;let g=0;for(let e=0;e<t.length;e++){const r=t[e];let o=a.get(r);o||(o=a.set(r,new Set).get(r)),o.add(r);const f=d&&y.get(s).get(r)||!o.has(s)&&Le(c,s,r);if(y.get(s).set(r,f),f)o.add(s);else if(!Le(c,s,r)){o.delete(s);continue}const u=l;if(i.setUint32(l,r),l+=4,n[E])g++;else if(ArrayBuffer.isView(n[r])){const e=n[r].constructor.name.replace("Array",""),t=n[r][b],o=n[r][S],s=l;l+=o;let a=0;for(let s=0;s<n[r].length;s++){if(d){const e=d[r][s]!==n[r][s];if(d[r][s]=n[r][s],!e&&!f)continue}i[`set${t}`](l,s),l+=o;const c=n[r][s];i[`set${e}`](l,c),l+=n[r].BYTES_PER_ELEMENT,a++}if(!(a>0)){l=u;continue}i[`set${t}`](s,a),g++}else{if(d){const e=d[r]!==n[r];if(d[r]=n[r],!e&&!f){l=u;continue}}const e=n.constructor.name.replace("Array","");i[`set${e}`](l,n[r]),l+=n.BYTES_PER_ELEMENT,g++}}g>0?i.setUint32(h,g):l-=5}return s.slice(0,l)}},D=new Map,J=e=>{const t=Object.getOwnPropertySymbols(e).includes(Be);let[n]=F(e);const r=new Set;return(o,s,i=0)=>{D.clear(),k&&([n]=F(e),k=!1),t&&(n=[],e[Be].forEach(((e,t)=>{t[f]?n.push(...t[f]):n.push(t)})));const a=o[Fe],c=o[Qe],l=new DataView(s);let y=0;for(;y<s.byteLength;){const e=l.getUint8(y);y+=1;const t=l.getUint32(y);y+=4;const s=n[e];for(let e=0;e<t;e++){let e=l.getUint32(y);if(y+=4,i===_.MAP)if(a.has(e))e=a.get(e);else if(D.has(e))e=D.get(e);else{const t=se(o);a.set(e,t),c.set(t,e),D.set(e,t),e=t}if(i===_.APPEND||i===_.REPLACE&&!o[K].has(e)){const t=D.get(e)||se(o);D.set(e,t),e=t}const t=s[u]();if(Le(o,t,e)||xe(o,t,e),r.add(e),!t[E])if(ArrayBuffer.isView(s[e])){const t=s[e],n=l[`get${t[b]}`](y);y+=t[S];for(let r=0;r<n;r++){const n=l[`get${t[b]}`](y);y+=t[S];const r=l[`get${t.constructor.name.replace("Array","")}`](y);if(y+=t.BYTES_PER_ELEMENT,s[w]){let t;if(a.has(r))t=a.get(r);else if(D.has(r))t=D.get(r);else{const e=se(o);a.set(r,e),c.set(e,r),D.set(r,e),t=e}s[e][n]=t}else s[e][n]=r}}else{const t=l[`get${s.constructor.name.replace("Array","")}`](y);if(y+=s.BYTES_PER_ELEMENT,s[w]){let n;if(a.has(t))n=a.get(t);else if(D.has(t))n=D.get(t);else{const e=se(o);a.set(t,e),c.set(e,t),D.set(t,e),n=e}s[e]=n}else s[e]=t}}}const d=Array.from(r);return r.clear(),d}},G=Symbol("entityMasks"),H=Symbol("entityComponents"),K=Symbol("entitySparseSet"),W=Symbol("entityArray"),X=1e5,Z=0,ee=X,te=()=>ee,ne=[],re=e=>{const t=ee;ee=X=e,Z=0,ne.length=0,ee=e,Je(e),ke(e),k=!0,console.info(`ðŸ‘¾ bitECS - resizing all data stores from ${t} to ${e}`)},oe=new Map,se=e=>{if(Z>=ee-ee/5){const e=ee,t=4*Math.ceil(e/2/4);re(e+t)}const t=ne.length>Math.round(.01*X)?ne.shift():Z++;return e[K].add(t),oe.set(t,e),e[ye].forEach((n=>{Oe(e,n,t)&&ve(n,t)})),e[H].set(t,new Set),t},ie=(e,t)=>{if(e[K].has(t)){e[ue].forEach((n=>{Re(e,n,t)})),ne.push(t),e[K].remove(t),e[H].delete(t),e[Fe].delete(e[Qe].get(t)),e[Qe].delete(t);for(let n=0;n<e[G].length;n++)e[G][n][t]=0}},ae=(e,t)=>{if(void 0===t)throw new Error("bitECS - entity is undefined.");if(!e[K].has(t))throw new Error("bitECS - entity does not exist in the world.");return Array.from(e[H].get(t))},ce=(e,t)=>e[K].has(t);function le(e){return()=>[e,"not"]}function fe(e){return()=>[e,"changed"]}var ue=Symbol("queries"),ye=Symbol("notQueries"),de=Symbol("queryAny"),he=Symbol("queryAll"),ge=Symbol("queryNone"),pe=Symbol("queryMap"),me=Symbol("$dirtyQueries"),Ee=Symbol("queryComponents"),be=e=>t=>{t[pe].has(e)||we(t,e);const n=t[pe].get(e),r=n.entered.dense.slice();return n.entered=B(),r},Se=e=>t=>{t[pe].has(e)||we(t,e);const n=t[pe].get(e),r=n.exited.dense.slice();return n.exited=B(),r},we=(e,t)=>{const n=[],r=[],o=[];t[Ee].forEach((t=>{if("function"==typeof t){const[s,i]=t();e[Be].has(s)||Ie(e,s),"not"===i&&r.push(s),"changed"===i&&(o.push(s),n.push(s))}else e[Be].has(t)||Ie(e,t),n.push(t)}));const s=t=>e[Be].get(t),i=n.concat(r).map(s),a=B(),c=B(),l=B(),u=B(),y=i.map((e=>e.generationId)).reduce(((e,t)=>(e.includes(t)||e.push(t),e)),[]),d=(e,t)=>(e[t.generationId]||(e[t.generationId]=0),e[t.generationId]|=t.bitflag,e),h=n.map(s).reduce(d,{}),g=r.map(s).reduce(d,{}),p=i.reduce(d,{}),m=n.filter((e=>!e[E])).map((e=>Object.getOwnPropertySymbols(e).includes(f)?e[f]:[e])).reduce(((e,t)=>e.concat(t)),[]),b=Object.assign(a,{archetypes:[],changed:[],components:n,notComponents:r,changedComponents:o,allComponents:i,masks:h,notMasks:g,hasMasks:p,generations:y,flatProps:m,toRemove:c,entered:l,exited:u,shadows:[]});e[pe].set(t,b),e[ue].add(b),i.forEach((e=>{e.queries.add(b)})),r.length&&e[ye].add(b);for(let t=0;t<Z;t++){if(!e[K].has(t))continue;Oe(e,b,t)&&ve(b,t)}},Ae=(e,t)=>{const n=Symbol(),r=e.flatProps[t];return O(r,n),e.shadows[t]=r[n],r[n]},Me=(...e)=>{let t;if(Array.isArray(e[0])&&(t=e[0]),void 0===t||void 0!==t[Be])return e=>e?e[W]:t[W];const n=function(e,t=!0){e[pe].has(n)||we(e,n);const r=e[pe].get(n);return Ce(e),r.changedComponents.length?((e,t)=>{t&&(e.changed=[]);const{flatProps:n,shadows:r}=e;for(let t=0;t<e.dense.length;t++){const o=e.dense[t];let s=!1;for(let t=0;t<n.length;t++){const i=n[t],a=r[t]||Ae(e,t);if(ArrayBuffer.isView(i[o])){for(let e=0;e<i[o].length;e++)if(i[o][e]!==a[o][e]){s=!0;break}a[o].set(i[o])}else i[o]!==a[o]&&(s=!0,a[o]=i[o])}s&&e.changed.push(o)}return e.changed})(r,t):r.dense};return n[Ee]=t,n[de]=undefined,n[he]=undefined,n[ge]=undefined,n},Oe=(e,t,n)=>{const{masks:r,notMasks:o,generations:s}=t;for(let t=0;t<s.length;t++){const i=s[t],a=r[i],c=o[i],l=e[G][i][n];if(c&&0!=(l&c))return!1;if(a&&(l&a)!==a)return!1}return!0},ve=(e,t)=>{e.toRemove.remove(t),e.entered.add(t),e.add(t)},Pe=e=>{for(let t=e.toRemove.dense.length-1;t>=0;t--){const n=e.toRemove.dense[t];e.toRemove.remove(n),e.remove(n)}},Ce=e=>{e[me].size&&(e[me].forEach(Pe),e[me].clear())},Re=(e,t,n)=>{t.has(n)&&!t.toRemove.has(n)&&(t.toRemove.add(n),e[me].add(t),t.exited.add(n))},Te=(e,t)=>{e[pe].get(t).changed=[]},je=(e,t)=>{const n=e[pe].get(t);e[ue].delete(n),e[pe].delete(t)},Be=Symbol("componentMap"),_e=[],ke=e=>{_e.forEach((t=>P(t,e)))},Ue=(e,t)=>{const n=j(e,t||te());return e&&Object.keys(e).length&&_e.push(n),n},Ie=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,r=new Set,o=new Set;e[ue].forEach((e=>{e.allComponents.includes(t)&&n.add(e)})),e[Be].set(t,{generationId:e[G].length-1,bitflag:e[Ve],store:t,queries:n,notQueries:r,changedQueries:o}),t[c]<te()&&P(t,te()),(e=>{e[Ve]*=2,e[Ve]>=2**31&&(e[Ve]=1,e[G].push(new Uint32Array(e[qe])))})(e)},Ne=(e,t)=>{t.forEach((t=>Ie(e,t)))},Le=(e,t,n)=>{const r=e[Be].get(t);if(!r)return!1;const{generationId:o,bitflag:s}=r;return(e[G][o][n]&s)===s},xe=(e,t,n,r=!1)=>{if(void 0===n)throw new Error("bitECS - entity is undefined.");if(!e[K].has(n))throw new Error("bitECS - entity does not exist in the world.");if(e[Be].has(t)||Ie(e,t),Le(e,t,n))return;const o=e[Be].get(t),{generationId:s,bitflag:i,queries:a,notQueries:c}=o;e[G][s][n]|=i,a.forEach((t=>{t.toRemove.has(n)&&t.toRemove.remove(n);const r=Oe(e,t,n);r&&ve(t,n),r||Re(e,t,n)})),e[H].get(n).add(t),r&&C(t,n)},$e=(e,t,n,r=!0)=>{if(void 0===n)throw new Error("bitECS - entity is undefined.");if(!e[K].has(n))throw new Error("bitECS - entity does not exist in the world.");if(!Le(e,t,n))return;const o=e[Be].get(t),{generationId:s,bitflag:i,queries:a}=o;e[G][s][n]&=~i,a.forEach((t=>{t.toRemove.has(n)&&t.toRemove.remove(n);const r=Oe(e,t,n);r&&ve(t,n),r||Re(e,t,n)})),e[H].get(n).delete(t),r&&C(t,n)},qe=Symbol("size"),Ye=Symbol("resizeThreshold"),Ve=Symbol("bitflag"),ze=Symbol("archetypes"),Fe=Symbol("localEntities"),Qe=Symbol("localEntityLookp"),De=[],Je=e=>{De.forEach((t=>{t[qe]=e;for(let n=0;n<t[G].length;n++){const r=t[G][n];t[G][n]=M(r,e)}t[Ye]=t[qe]-t[qe]/5}))},Ge=(...e)=>{const t="object"==typeof e[0]?e[0]:{},n="number"==typeof e[0]?e[0]:"number"==typeof e[1]?e[1]:te();return He(t,n),De.push(t),t},He=(e,t=te())=>(e[qe]=t,e[W]&&e[W].forEach((t=>ie(e,t))),e[G]=[new Uint32Array(t)],e[H]=new Map,e[ze]=[],e[K]=B(),e[W]=e[K].dense,e[Ve]=1,e[Be]=new Map,e[pe]=new Map,e[ue]=new Set,e[ye]=new Set,e[me]=new Set,e[Fe]=new Map,e[Qe]=new Map,e),Ke=e=>{Object.getOwnPropertySymbols(e).forEach((t=>{delete e[t]})),Object.keys(e).forEach((t=>{delete e[t]})),De.splice(De.indexOf(e),1)},We=e=>Array.from(e[Be].keys()),Xe=e=>(t,...n)=>(e(t,...n),t),Ze=(...e)=>t=>{let n=t;for(let t=0;t<e.length;t++){n=(0,e[t])(n)}return n},et=t;export{fe as Changed,_ as DESERIALIZE_MODE,le as Not,et as Types,xe as addComponent,se as addEntity,Ce as commitRemovals,Ge as createWorld,Ue as defineComponent,J as defineDeserializer,Me as defineQuery,Q as defineSerializer,Xe as defineSystem,Ke as deleteWorld,be as enterQuery,ce as entityExists,Se as exitQuery,ae as getEntityComponents,We as getWorldComponents,Le as hasComponent,R as parentArray,Ze as pipe,Ie as registerComponent,Ne as registerComponents,$e as removeComponent,ie as removeEntity,je as removeQuery,Te as resetChangedQuery,He as resetWorld,re as setDefaultSize};export default null;
//# sourceMappingURL=/bitecs.mjs.map
